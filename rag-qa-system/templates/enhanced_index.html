<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG QA System - Enhanced</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .chat-container {
            height: 500px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 10px;
            position: relative;
        }
        .message-time {
            font-size: 0.75em;
            color: #6c757d;
            margin-top: 5px;
            opacity: 0.8;
        }
        .user-message {
            background-color: #007bff;
            color: white;
            text-align: right;
            margin-left: 20%;
        }
        .ai-message {
            background-color: #e9ecef;
            margin-right: 20%;
            line-height: 1.6;
        }
        .ai-message h3 {
            color: #0066cc;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .ai-message table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        .ai-message table th,
        .ai-message table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .ai-message table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .ai-message strong {
            color: #0066cc;
        }
        .ai-message ul, .ai-message ol {
            padding-left: 20px;
        }
        .ai-message li {
            margin-bottom: 5px;
        }
        .ai-message .list-check {
            list-style: none;
            padding-left: 0;
        }
        .ai-message .list-check li {
            padding-left: 25px;
            position: relative;
        }
        .ai-message .table-bordered {
            border: 2px solid #dee2e6;
        }
        .ai-message .table-bordered th,
        .ai-message .table-bordered td {
            border: 1px solid #dee2e6;
            vertical-align: middle;
        }
        .source-doc {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
            padding: 5px;
            background-color: #f1f3f5;
            border-radius: 5px;
        }
        .upload-section {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .document-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .settings-section {
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .model-selector {
            margin-bottom: 15px;
        }
        .vectordb-info {
            background-color: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .progress-container {
            margin: 15px 0;
            display: none;
        }
        .progress {
            height: 25px;
        }
        .progress-bar {
            transition: width 0.3s ease;
            font-size: 0.9em;
        }
        .chunking-strategy-section {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #dee2e6;
        }
        .search-results {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .search-header {
            font-weight: bold;
            color: #0066cc;
            margin-bottom: 10px;
        }
        .search-result-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background-color: white;
            border-radius: 5px;
            border: 1px solid #e9ecef;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .result-rank {
            background-color: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            margin-right: 10px;
            min-width: 40px;
            text-align: center;
        }
        .result-info {
            flex: 1;
        }
        .result-source {
            background-color: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            margin-right: 8px;
        }
        .result-title {
            font-weight: 500;
            margin-right: 8px;
        }
        .result-score {
            color: #28a745;
            font-weight: bold;
            font-size: 0.9em;
        }
        .search-status {
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 5px;
            margin: 10px 0;
        }
        .llm-status {
            padding: 10px;
            background-color: #fff3cd;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #ffc107;
        }
        .ai-answer {
            margin: 15px 0;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            line-height: 1.6;
        }
        .document-group {
            margin: 20px 0;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            background-color: #fafafa;
        }
        .doc-group-title {
            color: #0066cc;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }
        .individual-answer {
            margin: 10px 0;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.3s ease-out;
        }
        .rank-badge {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }
        .score-badge {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            display: inline-block;
        }
        .rank-answer {
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin: 8px 0;
            padding: 12px;
            background-color: #f8f9fa;
        }
        .rank-header {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .source-info {
            margin-top: 8px;
            font-size: 0.8em;
            color: #6c757d;
            font-style: italic;
        }
        .process-status {
            color: #6c757d;
            font-style: italic;
            margin: 5px 0;
        }
        .error-message {
            color: #dc3545;
            font-weight: bold;
            font-size: 0.9em;
        }
        .process-answer {
            margin: 15px 0;
            padding: 15px;
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            line-height: 1.6;
        }
        .search-info-section {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        .search-info-section h6 {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 0.9em;
        }
        .search-doc-info {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
            font-size: 0.8em;
        }
        .doc-rank {
            background: #007bff;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
            min-width: 25px;
            text-align: center;
        }
        .doc-score {
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
        }
        .doc-source {
            color: #6c757d;
            font-style: italic;
        }
        .source-badge {
            background: #6c757d;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            margin-left: 5px;
        }
        .llm-response {
            margin: 15px 0;
            padding: 15px;
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }
        .llm-response h6 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 0.9em;
        }
        .answer-section {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        .similarity-section {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }
        .similarity-section h6 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 0.9em;
        }
        .similarity-item {
            margin: 10px 0;
            padding: 10px;
            background-color: #ffffff;
            border-radius: 6px;
            border-left: 3px solid #007bff;
        }
        .similarity-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }
        .similarity-rank {
            font-weight: bold;
            color: #007bff;
        }
        .similarity-score {
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.8em;
        }
        .similarity-source {
            color: #6c757d;
            font-size: 0.8em;
        }
        .similarity-content {
            color: #495057;
            font-size: 0.85em;
            line-height: 1.4;
            font-style: italic;
        }
            margin-right: 15px;
            min-width: 60px;
            text-align: center;
            flex-shrink: 0;
        }
        .answer-status {
            flex: 1;
            padding: 10px;
            background-color: #fff3cd;
            border-radius: 5px;
            border: 1px solid #ffc107;
        }
        .answer-content {
            flex: 1;
            line-height: 1.6;
            font-size: 0.95em;
        }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1 class="text-center mb-4">🤖 RAG QA System - Enhanced</h1>
        
        <!-- Settings Section -->
        <div class="settings-section">
            <h4><i class="fas fa-cog"></i> 시스템 설정</h4>
            <div class="row">
                <div class="col-md-4">
                    <label class="form-label">LLM 모델 선택:</label>
                    <select class="form-select model-selector" id="llmModel">
                        <option value="gpt-4o-mini" selected>GPT-4o-mini (빠름)</option>
                        <option value="gpt-4-turbo">GPT-4.1-mini (정확함)</option>
                    </select>
                </div>
                <div class="col-md-4">
                    <label class="form-label">청크 크기:</label>
                    <input type="number" class="form-control" id="chunkSize" value="1000">
                </div>
                <div class="col-md-4">
                    <label class="form-label">청크 겹침:</label>
                    <input type="number" class="form-control" id="chunkOverlap" value="200">
                </div>
            </div>
            
            <!-- 청킹 전략 선택 섹션 -->
            <div class="chunking-strategy-section">
                <h5><i class="fas fa-cut"></i> 청킹 전략 설정</h5>
                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label">청킹 전략:</label>
                        <select class="form-select" id="chunkingStrategy">
                            <option value="basic" selected>기본 청킹 (1000자/200자 중첩)</option>
                            <option value="custom_delimiter">커스텀 구분자 (/$$/ 기준)</option>
                            <option value="semantic">의미 기반 청킹</option>
                            <option value="hybrid">하이브리드 청킹</option>
                        </select>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">검색 모드:</label>
                        <select class="form-select" id="searchMode">
                            <option value="basic" selected>기본 청킹만 검색</option>
                            <option value="custom">커스텀 청킹만 검색</option>
                            <option value="dual">이중 검색 (기본+커스텀)</option>
                        </select>
                    </div>
                </div>
                <div class="mt-2">
                    <small class="text-muted">
                        💡 /$$/ 구분자가 포함된 문서는 자동으로 커스텀 청킹이 적용됩니다.
                    </small>
                </div>
            </div>
            <div class="vectordb-info mt-3">
                <strong>📊 벡터DB 정보:</strong> <span id="vectorDbInfo">로딩 중...</span>
                <button class="btn btn-sm btn-outline-danger ms-2" onclick="clearVectorDB()">
                    <i class="fas fa-trash"></i> DB 초기화
                </button>
                
                <!-- 성능 설명 -->
                <div class="mt-2">
                    <small class="text-info">
                        <i class="fas fa-info-circle"></i> 
                        <strong>성능 정보:</strong> 
                        문서 업로드 시 1-3초 소요 (OpenAI 임베딩 생성), 
                        검색 시 캐시 활용으로 0.2초 이내 응답
                    </small>
                </div>
            </div>
        </div>
        
        <!-- Document Upload Section -->
        <div class="upload-section">
            <h4><i class="fas fa-upload"></i> 문서 관리</h4>
            
            <!-- S3 Auto Load -->
            <div class="row mb-3">
                <div class="col-md-12">
                    <button class="btn btn-success w-100" onclick="loadS3Documents()">
                        <i class="fas fa-folder-open"></i> S3 폴더 문서 자동 로드
                    </button>
                </div>
            </div>
            
            <!-- File Upload -->
            <div class="row">
                <div class="col-md-8">
                    <input type="file" class="form-control" id="fileInput" accept=".pdf,.txt,.docx,.md">
                </div>
                <div class="col-md-4">
                    <button class="btn btn-primary w-100" onclick="uploadDocument()">
                        <i class="fas fa-upload"></i> 파일 업로드
                    </button>
                </div>
            </div>
            
            <!-- 진행률 표시 -->
            <div class="progress-container" id="progressContainer">
                <div class="progress">
                    <div class="progress-bar bg-primary" id="progressBar" role="progressbar" style="width: 0%">
                        <span id="progressText">대기 중...</span>
                    </div>
                </div>
                <div class="mt-2">
                    <small id="progressDetails" class="text-muted">
                        💡 문서 처리는 임베딩 생성으로 인해 1-3초 소요됩니다. 검색은 캐시로 0.2초 이내!
                    </small>
                </div>
            </div>
            
            <!-- Text Input -->
            <div class="mt-3">
                <h5>또는 텍스트 직접 입력:</h5>
                <textarea class="form-control" id="textInput" rows="3" placeholder="텍스트를 입력하세요..."></textarea>
                <div class="mt-2">
                    <input type="text" class="form-control mb-2" id="textTitle" placeholder="문서 제목 (선택)">
                    <button class="btn btn-secondary" onclick="uploadText()">
                        <i class="fas fa-plus"></i> 텍스트 추가
                    </button>
                </div>
            </div>
            
            <!-- Document List -->
            <div class="mt-3">
                <h5>📚 문서 현황:</h5>
                <div id="documentList" class="document-list"></div>
                <button class="btn btn-danger btn-sm mt-2" onclick="clearAllDocuments()">
                    <i class="fas fa-trash"></i> 모든 문서 삭제
                </button>
            </div>
        </div>
        
        <!-- Chat Interface -->
        <div class="card">
            <div class="card-body">
                <div class="chat-container" id="chatContainer">
                    <div class="message ai-message">
                        <h3>🤖 RAG QA 시스템에 오신 것을 환영합니다!</h3>
                        <p>문서를 업로드하고 질문해주세요. 다음 기능들을 사용할 수 있습니다:</p>
                        <ul>
                            <li><strong>S3 자동 로드:</strong> 미리 준비된 문서들을 한번에 로드</li>
                            <li><strong>LLM 모델 선택:</strong> GPT-4o-mini 또는 GPT-4.1-mini 선택</li>
                            <li><strong>실시간 설정:</strong> 청킹 크기 및 겹침 조정</li>
                        </ul>
                    </div>
                </div>
                <div class="input-group mt-3">
                    <input type="text" class="form-control" id="questionInput" placeholder="질문을 입력하세요..." onkeypress="handleKeyPress(event)">
                    <button class="btn btn-primary" onclick="sendQuestion()">
                        <i class="fas fa-paper-plane"></i> 전송
                    </button>
                    <button class="btn btn-secondary" onclick="clearChat()">
                        <i class="fas fa-eraser"></i> 초기화
                    </button>
                </div>
                <div class="form-check mt-2">
                    <input class="form-check-input" type="checkbox" id="useMemory">
                    <label class="form-check-label" for="useMemory">
                        대화 기록 사용
                    </label>
                </div>
            </div>
        </div>
        
        <!-- API Documentation Link -->
        <div class="text-center mt-4">
            <a href="/swagger/" class="btn btn-outline-info" target="_blank">
                <i class="fas fa-book"></i> API 문서 (Swagger)
            </a>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // Load initial data
        window.onload = function() {
            loadDocumentList();
            loadVectorDBInfo();
        };

        // Get current time in HH:MM:SS format
        function getCurrentTime() {
            const now = new Date();
            return now.toLocaleTimeString('ko-KR', { 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit',
                hour12: false 
            });
        }

        // Advanced markdown formatting function
        function formatMarkdown(text) {
            // First, handle tables (most important fix)
            text = formatTables(text);
            
            // Headers
            text = text.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            text = text.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            text = text.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            
            // Bold and italic
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Lists
            text = formatLists(text);
            
            // Line breaks and paragraphs
            text = text.replace(/\n\n/g, '</p><p>');
            text = '<p>' + text + '</p>';
            
            // Clean up empty paragraphs and fix structure
            text = text.replace(/<p><\/p>/g, '');
            text = text.replace(/<p>(<h[1-6])/g, '$1');
            text = text.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
            text = text.replace(/<p>(<table)/g, '$1');
            text = text.replace(/(<\/table>)<\/p>/g, '$1');
            text = text.replace(/<p>(<ul)/g, '$1');
            text = text.replace(/(<\/ul>)<\/p>/g, '$1');
            text = text.replace(/<p>(<ol)/g, '$1');
            text = text.replace(/(<\/ol>)<\/p>/g, '$1');
            
            return text;
        }

        function formatTables(text) {
            // Enhanced table formatting
            const tablePattern = /(\|[^|\n]*\|[^|\n]*\|[^\n]*\n)+/g;
            
            return text.replace(tablePattern, (match) => {
                const rows = match.trim().split('\n');
                if (rows.length < 2) return match;
                
                let table = '<table class="table table-striped table-bordered">';
                let hasHeader = false;
                
                rows.forEach((row, index) => {
                    // Skip separator rows like |---|---|
                    if (row.includes('---') || row.includes(':--')) {
                        hasHeader = true;
                        return;
                    }
                    
                    const cells = row.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
                    
                    if (cells.length === 0) return;
                    
                    // First row is header if we haven't seen a separator yet, or if this is the first row
                    const isHeader = (index === 0 && !hasHeader);
                    const tag = isHeader ? 'th' : 'td';
                    const section = isHeader ? 'thead' : 'tbody';
                    
                    if (isHeader && index === 0) {
                        table += '<thead>';
                    } else if (!isHeader && index === 1 && hasHeader) {
                        table += '</thead><tbody>';
                    } else if (!isHeader && index === 1 && !hasHeader) {
                        table += '<tbody>';
                    }
                    
                    table += '<tr>';
                    cells.forEach(cell => {
                        // Process cell content for markdown
                        let cellContent = cell;
                        cellContent = cellContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                        cellContent = cellContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
                        table += `<${tag}>${cellContent}</${tag}>`;
                    });
                    table += '</tr>';
                });
                
                if (hasHeader) {
                    table += '</tbody>';
                } else {
                    table += '</tbody>';
                }
                table += '</table>';
                
                return table;
            });
        }

        function formatLists(text) {
            // Enhanced list formatting
            const lines = text.split('\n');
            let result = [];
            let inList = false;
            let listType = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const isUnorderedItem = /^\s*[-*+]\s+(.+)/.test(line);
                const isOrderedItem = /^\s*\d+\.\s+(.+)/.test(line);
                const isCheckItem = /^\s*[-*+]\s*✅\s*(.+)/.test(line);
                
                if (isCheckItem) {
                    const content = line.replace(/^\s*[-*+]\s*✅\s*/, '');
                    if (!inList || listType !== 'check') {
                        if (inList) result.push(`</${listType}>`);
                        result.push('<ul class="list-check">');
                        inList = true;
                        listType = 'check';
                    }
                    result.push(`<li><i class="fas fa-check-circle text-success"></i> ${content}</li>`);
                } else if (isUnorderedItem) {
                    const content = line.replace(/^\s*[-*+]\s+/, '');
                    if (!inList || listType !== 'ul') {
                        if (inList) result.push(`</${listType}>`);
                        result.push('<ul>');
                        inList = true;
                        listType = 'ul';
                    }
                    result.push(`<li>${content}</li>`);
                } else if (isOrderedItem) {
                    const content = line.replace(/^\s*\d+\.\s+/, '');
                    if (!inList || listType !== 'ol') {
                        if (inList) result.push(`</${listType}>`);
                        result.push('<ol>');
                        inList = true;
                        listType = 'ol';
                    }
                    result.push(`<li>${content}</li>`);
                } else {
                    if (inList) {
                        result.push(`</${listType}>`);
                        inList = false;
                        listType = '';
                    }
                    result.push(line);
                }
            }
            
            if (inList) {
                result.push(`</${listType}>`);
            }
            
            return result.join('\n');
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendQuestion();
            }
        }

        // Progress bar utility functions with timing
        let uploadStartTime = 0;
        
        function showProgress(text, percentage, showTiming = false) {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            const textElement = document.getElementById('progressText');
            const detailsElement = document.getElementById('progressDetails');
            
            container.style.display = 'block';
            bar.style.width = percentage + '%';
            
            if (percentage === 0) {
                uploadStartTime = Date.now();
                textElement.textContent = text;
                detailsElement.innerHTML = '🔄 시작 중...';
            } else if (percentage < 100) {
                const elapsed = ((Date.now() - uploadStartTime) / 1000).toFixed(1);
                textElement.textContent = text;
                
                if (percentage <= 30) {
                    detailsElement.innerHTML = `📁 파일 로딩 중... (${elapsed}초 경과)`;
                } else if (percentage <= 60) {
                    detailsElement.innerHTML = `✂️ 청킹 처리 중... (${elapsed}초 경과)`;
                } else if (percentage <= 90) {
                    detailsElement.innerHTML = `🤖 OpenAI 임베딩 생성 중... (${elapsed}초 경과) - 가장 오래 걸리는 단계`;
                } else {
                    detailsElement.innerHTML = `💾 벡터DB 저장 중... (${elapsed}초 경과)`;
                }
            } else {
                const totalTime = ((Date.now() - uploadStartTime) / 1000).toFixed(2);
                textElement.textContent = `완료! (총 ${totalTime}초)`;
                detailsElement.innerHTML = `✅ 처리 완료! 이제 빠른 검색이 가능합니다. (평균 0.2초)`;
                
                setTimeout(() => {
                    container.style.display = 'none';
                    bar.style.width = '0%';
                }, 3000);
            }
        }

        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }

        async function sendQuestion() {
            const input = document.getElementById('questionInput');
            const question = input.value.trim();
            if (!question) return;

            const chatContainer = document.getElementById('chatContainer');
            const useMemory = document.getElementById('useMemory').checked;
            const llmModel = document.getElementById('llmModel').value;
            const searchMode = document.getElementById('searchMode').value;

            // Add user message with timestamp
            const userTime = getCurrentTime();
            chatContainer.innerHTML += `<div class="message user-message">${question}<div class="message-time">${userTime}</div></div>`;
            input.value = '';

            // Create AI message container for streaming
            const aiMessageId = 'ai-message-' + Date.now();
            const loadingHTML = `
                <div class="message ai-message" id="${aiMessageId}">
                    <div class="streaming-content">
                        <div class="loading-indicator">
                            <i class="fas fa-search fa-spin"></i> 검색 중...
                        </div>
                    </div>
                    <div class="message-time">${getCurrentTime()}</div>
                </div>
            `;
            chatContainer.innerHTML += loadingHTML;
            chatContainer.scrollTop = chatContainer.scrollHeight;

            try {
                // Use streaming endpoint
                const response = await fetch('/api/chat/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        question: question,
                        use_memory: useMemory,
                        llm_model: llmModel,
                        search_mode: searchMode
                    })
                });

                if (!response.body) {
                    throw new Error('스트리밍을 지원하지 않습니다.');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                const aiMessageContainer = document.getElementById(aiMessageId);
                const contentContainer = aiMessageContainer.querySelector('.streaming-content');
                
                // Clear loading indicator
                contentContainer.innerHTML = '<div class="streaming-answer"></div>';
                const answerContainer = contentContainer.querySelector('.streaming-answer');

                let buffer = '';
                let isFirstChunk = true;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                // Add final timestamp and metadata
                                const finalTime = getCurrentTime();
                                aiMessageContainer.querySelector('.message-time').textContent = finalTime;
                                
                                // Add model info
                                const modelInfo = document.createElement('div');
                                modelInfo.className = 'mt-2';
                                modelInfo.innerHTML = `<small class="text-muted">🤖 Model: ${llmModel} (스트리밍)</small>`;
                                contentContainer.appendChild(modelInfo);
                                return;
                            }
                            
                            try {
                                const chunk = JSON.parse(data);
                                
                                if (chunk.type === 'search_start') {
                                    answerContainer.innerHTML = `<div class="search-status"><i class="fas fa-search fa-spin"></i> ${chunk.message}</div>`;
                                } else if (chunk.type === 'search_result_found') {
                                    // Show each search result immediately
                                    const searchResults = answerContainer.querySelector('.search-results') || 
                                        (() => {
                                            const div = document.createElement('div');
                                            div.className = 'search-results';
                                            div.innerHTML = '<div class="search-header"><i class="fas fa-file-search"></i> 검색 결과:</div>';
                                            answerContainer.appendChild(div);
                                            return div;
                                        })();
                                    
                                    const resultDiv = document.createElement('div');
                                    resultDiv.className = 'search-result-item';
                                    resultDiv.innerHTML = `
                                        <div class="result-rank">1위</div>
                                        <div class="result-info">
                                            <span class="result-source">[${chunk.source}]</span>
                                            <span class="result-title">${chunk.title}</span>
                                            <span class="result-score">${chunk.score}</span>
                                        </div>
                                    `;
                                    searchResults.appendChild(resultDiv);
                                } else if (chunk.type === 'search_completed') {
                                    // Search completed
                                    const statusDiv = answerContainer.querySelector('.search-status');
                                    if (statusDiv) {
                                        statusDiv.innerHTML = `<i class="fas fa-check text-success"></i> ${chunk.total_docs}개 문서 검색 완료 (${chunk.search_time}초)`;
                                    }
                                } else if (chunk.type === 'all_processes_start') {
                                    // 4개 프로세스 시작
                                    const processesDiv = document.createElement('div');
                                    processesDiv.className = 'processes-container';
                                    processesDiv.id = 'processes-container';
                                    processesDiv.innerHTML = '<h5 class="processes-title">🔄 4개 프로세스 비동기 실행 중...</h5>';
                                    answerContainer.appendChild(processesDiv);
                                } else if (chunk.type === 'process_start') {
                                    // 개별 프로세스 시작
                                    let processesContainer = document.getElementById('processes-container');
                                    if (!processesContainer) {
                                        processesContainer = document.createElement('div');
                                        processesContainer.className = 'processes-container';
                                        processesContainer.id = 'processes-container';
                                        answerContainer.appendChild(processesContainer);
                                    }
                                    
                                    const processDiv = document.createElement('div');
                                    processDiv.className = 'process-group';
                                    processDiv.id = `process-${chunk.process_id}`;
                                    processDiv.innerHTML = `
                                        <h6 class="process-title">📋 ${chunk.process_name}</h6>
                                        <div class="process-status">로딩 중...</div>
                                    `;
                                    processesContainer.appendChild(processDiv);
                                } else if (chunk.type === 'process_complete') {
                                    // 프로세스 완료 - 모든 순위 답변 표시
                                    const processDiv = document.getElementById(`process-${chunk.process_id}`);
                                    if (processDiv) {
                                        // 로딩 상태 제거
                                        const statusDiv = processDiv.querySelector('.process-status');
                                        if (statusDiv) {
                                            statusDiv.remove();
                                        }
                                        
                                        // 제목에 완료 표시와 시간 정보 추가
                                        const title = processDiv.querySelector('.process-title');
                                        if (title) {
                                            title.innerHTML += ` (응답 ${chunk.total_time}초, ${chunk.status === 'success' ? '성공' : '실패'}) ✅`;
                                        }
                                        
                                        // LLM 응답 내용 표시
                                        if (chunk.rank_answers && chunk.rank_answers.length > 0) {
                                            const responseDiv = document.createElement('div');
                                            responseDiv.className = 'llm-response';
                                            responseDiv.innerHTML = '<h6>💬 응답 내용:</h6>';
                                            
                                            chunk.rank_answers.forEach(rankData => {
                                                const answerDiv = document.createElement('div');
                                                answerDiv.className = 'answer-section';
                                                answerDiv.innerHTML = formatMarkdown(rankData.answer);
                                                responseDiv.appendChild(answerDiv);
                                            });
                                            
                                            processDiv.appendChild(responseDiv);
                                        }
                                        
                                        // 유사도 Top 3 표시
                                        if (chunk.similarity_info && chunk.similarity_info.length > 0) {
                                            const similarityDiv = document.createElement('div');
                                            similarityDiv.className = 'similarity-section';
                                            similarityDiv.innerHTML = '<h6>🔍 유사도 Top 3</h6>';
                                            
                                            chunk.similarity_info.forEach(info => {
                                                const simDiv = document.createElement('div');
                                                simDiv.className = 'similarity-item';
                                                simDiv.innerHTML = `
                                                    <div class="similarity-header">
                                                        <span class="similarity-rank">${info.rank}.</span>
                                                        <span class="similarity-score">(유사도 ${info.score})</span>
                                                        <span class="similarity-source">📄 ${info.source}</span>
                                                    </div>
                                                    <div class="similarity-content">${info.content_preview}</div>
                                                `;
                                                similarityDiv.appendChild(simDiv);
                                            });
                                            
                                            processDiv.appendChild(similarityDiv);
                                        }
                                    }
                                } else if (chunk.type === 'process_error') {
                                    // 프로세스 오류
                                    const processDiv = document.getElementById(`process-${chunk.process_id}`);
                                    if (processDiv) {
                                        const statusDiv = processDiv.querySelector('.process-status');
                                        if (statusDiv) {
                                            statusDiv.innerHTML = `<span class="error-message">❌ ${chunk.message || chunk.error}</span>`;
                                        }
                                        
                                        const title = processDiv.querySelector('.process-title');
                                        if (title) {
                                            const timeInfo = chunk.total_time ? ` (응답 ${chunk.total_time}초, 실패)` : '';
                                            title.innerHTML += `${timeInfo} ❌`;
                                        }
                                    }
                                } else if (chunk.type === 'source_docs') {
                                    // Add source documents
                                    if (chunk.docs && chunk.docs.length > 0) {
                                        const sourceDiv = document.createElement('div');
                                        sourceDiv.className = 'source-doc mt-2';
                                        sourceDiv.innerHTML = '<strong>📄 참고 문서:</strong><br>' + 
                                            chunk.docs.map((doc, idx) => 
                                                `${idx + 1}. ${doc.metadata?.source_file || doc.metadata?.title || 'Unknown'}`
                                            ).join('<br>');
                                        contentContainer.appendChild(sourceDiv);
                                    }
                                }
                                
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            } catch (e) {
                                console.error('JSON 파싱 오류:', e);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('스트리밍 오류:', error);
                // Fallback to regular query
                const aiMessageContainer = document.getElementById(aiMessageId);
                if (aiMessageContainer) {
                    aiMessageContainer.remove();
                }
                await sendQuestionFallback(question, useMemory, llmModel, searchMode);
            }
        }

        // Fallback function for non-streaming
        async function sendQuestionFallback(question, useMemory, llmModel, searchMode) {
            const chatContainer = document.getElementById('chatContainer');
            
            try {
                const response = await fetch('/api/chat/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        question: question,
                        use_memory: useMemory,
                        llm_model: llmModel,
                        search_mode: searchMode
                    })
                });

                const data = await response.json();
                
                if (data.error) {
                    const errorTime = getCurrentTime();
                    chatContainer.innerHTML += `<div class="message ai-message">❌ 오류: ${data.error}<div class="message-time">${errorTime}</div></div>`;
                } else {
                    // Format the answer with markdown
                    const formattedAnswer = formatMarkdown(data.answer || data.result);
                    const aiTime = getCurrentTime();
                    let aiMessage = `<div class="message ai-message">${formattedAnswer}`;
                    
                    // Add model info with response time
                    const responseTime = data.response_time ? ` (${data.response_time}초)` : '';
                    aiMessage += `<div class="mt-2"><small class="text-muted">🤖 Model: ${data.model_used || llmModel}${responseTime}</small></div>`;
                    
                    // Add source documents if available
                    if (data.source_documents && data.source_documents.length > 0) {
                        aiMessage += '<div class="source-doc"><strong>📄 참고 문서:</strong><br>';
                        data.source_documents.forEach((doc, idx) => {
                            aiMessage += `${idx + 1}. ${doc.metadata.source_file || doc.metadata.title || doc.metadata.filename || 'Unknown'}<br>`;
                        });
                        aiMessage += '</div>';
                    }
                    
                    aiMessage += `<div class="message-time">${aiTime}</div></div>`;
                    chatContainer.innerHTML += aiMessage;
                }
            } catch (error) {
                const errorTime = getCurrentTime();
                chatContainer.innerHTML += `<div class="message ai-message">❌ 오류: ${error.message}<div class="message-time">${errorTime}</div></div>`;
            }

            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function loadS3Documents() {
            try {
                const response = await fetch('/api/document/load-s3', {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.error) {
                    alert(`S3 로드 실패: ${data.error}`);
                } else {
                    alert(`S3 로드 성공! ${data.documents_loaded || 0}개 문서, ${data.total_chunks || 0}개 청크가 로드되었습니다.`);
                    loadDocumentList();
                    loadVectorDBInfo();
                }
            } catch (error) {
                alert(`오류: ${error.message}`);
            }
        }

        async function uploadDocument() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert('파일을 선택해주세요.');
                return;
            }

            const chunkingStrategy = document.getElementById('chunkingStrategy').value;
            const formData = new FormData();
            formData.append('file', file);
            formData.append('chunking_strategy', chunkingStrategy);

            try {
                showProgress('업로드 시작...', 0);
                
                const response = await fetch('/api/document/upload', {
                    method: 'POST',
                    body: formData
                });

                showProgress('서버 처리 중...', 50);
                const data = await response.json();
                
                if (data.error) {
                    hideProgress();
                    alert(`업로드 실패: ${data.error}`);
                } else {
                    showProgress('업로드 완료!', 100);
                    
                    const strategyText = getStrategyDisplayName(data.chunking_strategy || chunkingStrategy);
                    alert(`업로드 성공!\n` +
                          `청킹 전략: ${strategyText}\n` +
                          `생성된 청크 수: ${data.chunks_created || 0}개\n` +
                          `처리 시간: ${(data.processing_time || 0).toFixed(2)}초`);
                    
                    fileInput.value = '';
                    loadDocumentList();
                    loadVectorDBInfo();
                }
            } catch (error) {
                hideProgress();
                alert(`오류: ${error.message}`);
            }
        }

        function getStrategyDisplayName(strategy) {
            const strategies = {
                'basic': '기본 청킹',
                'custom_delimiter': '커스텀 구분자 (/$$/ 기준)',
                'semantic': '의미 기반 청킹',
                'hybrid': '하이브리드 청킹'
            };
            return strategies[strategy] || strategy;
        }

        async function uploadText() {
            const textInput = document.getElementById('textInput');
            const titleInput = document.getElementById('textTitle');
            const text = textInput.value.trim();
            const title = titleInput.value.trim() || 'Direct Input ' + new Date().toLocaleString();
            
            if (!text) {
                alert('텍스트를 입력해주세요.');
                return;
            }

            try {
                const response = await fetch('/api/document/upload-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        text: text,
                        title: title
                    })
                });

                const data = await response.json();
                if (data.error) {
                    alert(`업로드 실패: ${data.error}`);
                } else {
                    alert(`텍스트 추가 성공! ${data.chunks_created || 0}개의 청크가 생성되었습니다.`);
                    textInput.value = '';
                    titleInput.value = '';
                    loadDocumentList();
                    loadVectorDBInfo();
                }
            } catch (error) {
                alert(`오류: ${error.message}`);
            }
        }

        async function loadDocumentList() {
            try {
                const response = await fetch('/api/document/list');
                const data = await response.json();
                
                const listContainer = document.getElementById('documentList');
                if (data.files && data.files.length > 0) {
                    listContainer.innerHTML = data.files.map(file => 
                        `<div>📄 ${file.filename} (${(file.size / 1024).toFixed(2)} KB)</div>`
                    ).join('');
                    listContainer.innerHTML += `<div class="mt-2"><strong>총 청크 수: ${data.total_chunks || 0}</strong></div>`;
                } else {
                    listContainer.innerHTML = '<div class="text-muted">업로드된 문서가 없습니다.</div>';
                }
            } catch (error) {
                console.error('문서 목록 로드 실패:', error);
            }
        }

        async function loadVectorDBInfo() {
            try {
                const response = await fetch('/api/v1/vectordb/info');
                const data = await response.json();
                
                document.getElementById('vectorDbInfo').innerHTML = 
                    `총 ${data.total_documents || 0}개 문서, ${data.embedding_model || 'Unknown'} 임베딩, ${data.vector_db_type || 'Unknown'}`;
            } catch (error) {
                console.error('벡터DB 정보 로드 실패:', error);
            }
        }

        async function clearVectorDB() {
            if (!confirm('벡터 데이터베이스를 완전히 삭제하시겠습니까?')) return;

            try {
                const response = await fetch('/api/v1/vectordb/clear', {
                    method: 'DELETE'
                });

                const data = await response.json();
                const result = await response.json();
                alert(result.message || '벡터DB가 초기화되었습니다.');
                loadDocumentList();
                loadVectorDBInfo();
            } catch (error) {
                alert(`오류: ${error.message}`);
            }
        }

        async function clearAllDocuments() {
            if (!confirm('모든 문서를 삭제하시겠습니까?')) return;

            try {
                const response = await fetch('/api/document/clear-all', {
                    method: 'DELETE'
                });

                const data = await response.json();
                const result = await response.json();
                alert(result.message || '문서가 삭제되었습니다.');
                loadDocumentList();
                loadVectorDBInfo();
            } catch (error) {
                alert(`오류: ${error.message}`);
            }
        }

        async function clearChat() {
            document.getElementById('chatContainer').innerHTML = 
                '<div class="message ai-message"><h3>🤖 대화가 초기화되었습니다.</h3><p>새로운 질문을 해주세요.</p></div>';
            
            // Clear memory on server
            await fetch('/api/chat/clear-memory', { method: 'POST' });
        }
    </script>
</body>
</html>